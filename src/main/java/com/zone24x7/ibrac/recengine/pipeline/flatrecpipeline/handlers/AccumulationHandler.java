package com.zone24x7.ibrac.recengine.pipeline.flatrecpipeline.handlers;

import com.zone24x7.ibrac.recengine.enumeration.RecommendationType;
import com.zone24x7.ibrac.recengine.pojo.*;
import com.zone24x7.ibrac.recengine.pojo.rules.FilteringRulesResult;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
@Qualifier("accumulationHandler")
public class AccumulationHandler implements RecUnitHandler {

    /**
     * Handles the accumulation of the results generated by multiple handlers.
     *
     * @param recInputParams  the input parameters for recommendation generation
     * @param recStatusParams rec status parameters for recommendation generation
     * @param activeBundle    the activeBundle for recommendation generation
     */
    @Override
    public void handleTask(RecInputParams recInputParams, RecStatusParams recStatusParams, ActiveBundle activeBundle) {
        createRecResult(recInputParams, recStatusParams, activeBundle);
    }

    /**
     * Creates the recResult object based on the RecStatusParams and sets to status params
     *
     * @param recInputParams  input params carrying object
     * @param recStatusParams status carrying object
     * @param activeBundle    active bundle details object
     */
    private static void createRecResult(RecInputParams recInputParams, RecStatusParams recStatusParams, ActiveBundle activeBundle) {
        RecResult<FlatRecPayload> recResult = new RecResult<>();
        recResult.setPlaceHolder(recInputParams.getPlaceholder());
        recResult.setRecCycleStatus(recStatusParams.getRecCycleStatus());

        //Populate payload
        MultipleAlgorithmResult multipleAlgorithmResult = recStatusParams.getMultipleAlgorithmResult();
        FilteringRulesResult filteringRulesResult = recStatusParams.getFilteringRuleResult();

        recResult.setRecPayload(populateFlatRecPayload(multipleAlgorithmResult, filteringRulesResult));

        //Populate meta info
        RecMetaInfo recMetaInfo = new RecMetaInfo();
        if (multipleAlgorithmResult != null) {
            recMetaInfo.setAlgoToProductsMap(multipleAlgorithmResult.getAlgoToProductsMap());
            recMetaInfo.setAlgoToUsedCcp(multipleAlgorithmResult.getAlgoToUsedCcp());
            recMetaInfo.setBundleId(activeBundle.getId());
            recMetaInfo.setType(RecommendationType.FLAT_RECOMMENDATION);
            recMetaInfo.setLimitToApply(activeBundle.getLimitToApply());
        }

        //If filtering rule result exist
        if(filteringRulesResult != null) {
            recMetaInfo.setExecutedFilteringRuleInfoList(filteringRulesResult.getExecutedFilteringRuleInfo());
        }

        recResult.setRecMetaInfo(recMetaInfo);

        //Set to status params
        recStatusParams.setRecResult(recResult);
    }

    /**
     * Method to populate the the flatrec payload based on the input
     *
     * @param multipleAlgorithmResult multipleAlgorithmResult object
     * @param filteringRulesResult    filteringRulesResult object
     * @return a FlatRecPayload
     */
    private static FlatRecPayload populateFlatRecPayload(MultipleAlgorithmResult multipleAlgorithmResult,
                                                         FilteringRulesResult filteringRulesResult) {
        FlatRecPayload flatRecPayload = new FlatRecPayload();
        if (filteringRulesResult != null) {
            flatRecPayload.setProducts(filteringRulesResult.getFilteredRecommendedProductsList());
            flatRecPayload.setDisplayText(multipleAlgorithmResult.getDisplayText());
        } else if (multipleAlgorithmResult != null) {
            flatRecPayload.setProducts(multipleAlgorithmResult.getRecProducts());
            flatRecPayload.setDisplayText(multipleAlgorithmResult.getDisplayText());
        }
        return flatRecPayload;
    }
}
